---
import { Search, X } from "lucide-astro";
import SearchModalEmpty from "@/components/SearchModalEmpty.astro";
import SearchModalError from "@/components/SearchModalError.astro";
import SearchModalFooter from "@/components/SearchModalFooter.astro";
import SearchModalSkeleton from "@/components/SearchModalSkeleton.astro";
---

<!-- Search Modal -->
<div
  id="search-modal"
  class="fixed inset-0 z-50 hidden bg-black/80 backdrop-blur-sm"
  aria-hidden="true"
  data-state="closed"
  style="view-transition-name: none;"
>
  <div
    class="fixed left-0 right-0 bottom-0 sm:bottom-auto sm:left-1/2 sm:top-[10%] z-50 w-full sm:max-w-lg md:max-w-2xl sm:-translate-x-1/2"
  >
    <div
      id="search-modal-content"
      class="relative flex flex-col max-h-[85dvh] sm:max-h-[85vh] bg-background shadow-lg border border-border rounded-t-xl sm:rounded-lg overflow-hidden"
      role="dialog"
      aria-modal="true"
      aria-labelledby="search-title"
      style="view-transition-name: none;"
    >
      <div class="sm:hidden flex justify-center pt-2 pb-1">
        <div class="w-8 h-1 rounded-full bg-border"></div>
      </div>
      <!-- Header with Search Input -->
      <div class="flex items-center gap-3 px-4 py-4 border-b border-border">
        <Search class="w-5 h-5 text-muted-foreground shrink-0" />
        <input
          id="search-input"
          type="text"
          placeholder="Search posts and projects..."
          class="flex-1 bg-transparent border-0 outline-none text-foreground placeholder:text-muted-foreground text-base"
          autocomplete="off"
        />
        <button
          id="close-search-modal"
          class="p-2 text-muted-foreground hover:text-foreground hover:bg-muted rounded-md transition-colors shrink-0"
          aria-label="Close search"
        >
          <X class="w-4 h-4" />
        </button>
      </div>

      <!-- Results Container -->
      <div id="search-results" class="flex-1 min-h-0 overflow-y-auto overscroll-contain">
        <SearchModalSkeleton />
        <SearchModalEmpty />
        <SearchModalError />

        <!-- Results List -->
        <div id="search-results-list" class="hidden">
          <div id="results-container" class="divide-y divide-border"></div>

          <!-- Load More Button -->
          <div id="load-more-container" class="hidden p-4">
            <button
              id="load-more-btn"
              class="w-full py-2 px-4 bg-muted text-foreground rounded-md text-sm font-medium hover:bg-muted/80 transition-colors"
            >
              Load more results
            </button>
          </div>
        </div>
      </div>

      <SearchModalFooter />
    </div>
  </div>
</div>

<style is:global>
  #search-modal[data-state="open"] {
    animation: searchOverlayIn 150ms ease-out;
  }

  #search-modal[data-state="closed"] {
    animation: searchOverlayOut 150ms ease-in forwards;
  }

  #search-modal[data-state="open"] #search-modal-content {
    animation: searchContentIn 200ms ease-out;
  }

  #search-modal[data-state="closed"] #search-modal-content {
    animation: searchContentOut 150ms ease-in forwards;
  }

  @keyframes searchOverlayIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  @keyframes searchOverlayOut {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  @keyframes searchContentIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes searchContentOut {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(20px);
    }
  }

  @media (min-width: 640px) {
    @keyframes searchContentIn {
      from {
        opacity: 0;
        transform: scale(0.98);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes searchContentOut {
      from {
        opacity: 1;
        transform: scale(1);
      }
      to {
        opacity: 0;
        transform: scale(0.98);
      }
    }
  }

  /* Prevent body scroll when modal is open */
  body.search-modal-open {
    overflow: hidden;
  }

  /* Search result item focus state */
  .search-result-item {
    transition: background-color 150ms ease;
  }

  .search-result-item:hover,
  .search-result-item[data-focused="true"] {
    background-color: var(--muted);
  }

  /* Highlight search terms */
  .search-highlight {
    background-color: hsl(var(--primary) / 0.2);
    color: var(--foreground);
    font-weight: 600;
    border-radius: 0.125rem;
    padding: 0 0.125rem;
  }

  /* Safe area for mobile */
  .pb-safe {
    padding-bottom: env(safe-area-inset-bottom);
  }
</style>

<script>
  import { formatBlogDate } from "@/lib/utils";
  import {
    clearCallbacks,
    clearSearchIndex,
    getAllData,
    highlightText,
    initSearchIndex,
    search,
    setCallbacks,
  } from "@/lib/flexsearch";
  import type { SearchResult } from "@/pages/api/search-index.json";

  // DOM element references (re-queried on each init)
  let modal: HTMLElement | null;
  let searchInput: HTMLInputElement | null;
  let skeleton: HTMLElement | null;
  let emptyState: HTMLElement | null;
  let errorState: HTMLElement | null;
  let resultsList: HTMLElement | null;
  let resultsContainer: HTMLElement | null;
  let footer: HTMLElement | null;
  let loadMoreBtn: HTMLElement | null;
  let loadMoreContainer: HTMLElement | null;

  // State
  let isOpen = false;
  let results: SearchResult[] = [];
  let displayedCount = 10;
  let focusedIndex = -1;
  let indexInitialized = false;

  function showSkeleton() {
    skeleton?.classList.remove("hidden");
    emptyState?.classList.add("hidden");
    errorState?.classList.add("hidden");
    resultsList?.classList.add("hidden");
    footer?.classList.add("hidden");
  }

  function showEmpty() {
    skeleton?.classList.add("hidden");
    emptyState?.classList.remove("hidden");
    emptyState?.classList.add("flex");
    errorState?.classList.add("hidden");
    resultsList?.classList.add("hidden");
    footer?.classList.add("hidden");
  }

  function showError(_errorMsg: string) {
    skeleton?.classList.add("hidden");
    emptyState?.classList.add("hidden");
    errorState?.classList.remove("hidden");
    errorState?.classList.add("flex");
    resultsList?.classList.add("hidden");
    footer?.classList.add("hidden");
  }

  function showResults() {
    skeleton?.classList.add("hidden");
    emptyState?.classList.add("hidden");
    emptyState?.classList.remove("flex");
    errorState?.classList.add("hidden");
    errorState?.classList.remove("flex");
    resultsList?.classList.remove("hidden");
    footer?.classList.remove("hidden");
    footer?.classList.add("flex");
  }

  function renderResults() {
    if (!resultsContainer) return;

    const query = searchInput?.value || "";

    if (results.length === 0) {
      if (query.trim()) {
        showEmpty();
      } else {
        const allData = getAllData();
        if (allData.length > 0) {
          results = allData.slice(0, 3);
          renderResultsList(results, query);
          showResults();
        } else {
          showEmpty();
        }
      }
      return;
    }

    const displayResults = results.slice(0, displayedCount);
    renderResultsList(displayResults, query);
    showResults();

    if (loadMoreContainer) {
      if (results.length > displayedCount) {
        loadMoreContainer.classList.remove("hidden");
        if (loadMoreBtn) {
          loadMoreBtn.textContent = `Load more (${results.length - displayedCount} remaining)`;
        }
      } else {
        loadMoreContainer.classList.add("hidden");
      }
    }
  }

  function renderResultsList(items: SearchResult[], query: string) {
    if (!resultsContainer) return;

    resultsContainer.innerHTML = items
      .map((item, index) => {
        const icon = item.type === "blog" ? "file-text" : "code";
        const highlightedTitle = highlightText(item.title, query);
        const highlightedDesc = highlightText(item.description, query);

        return `
          <a
            href="${item.url}"
            class="search-result-item block p-4 focus:outline-none focus:bg-muted"
            data-index="${index}"
            data-focused="false"
          >
            <div class="flex items-start gap-3">
              <div class="shrink-0 mt-0.5">
                ${getIconSvg(icon)}
              </div>
              <div class="flex-1 min-w-0">
                <h4 class="font-medium text-foreground mb-1 line-clamp-1">
                  ${highlightedTitle}
                </h4>
                <p class="text-sm text-muted-foreground mb-2 line-clamp-2">
                  ${highlightedDesc}
                </p>
                <div class="flex items-center gap-3 text-xs text-muted-foreground">
                  <span class="flex items-center gap-1">
                    <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    ${formatBlogDate(new Date(item.date))}
                  </span>
                  ${
                    item.tags.length > 0
                      ? `
                    <span class="flex items-center gap-1">
                      <svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                      </svg>
                      ${item.tags.slice(0, 3).join(", ")}
                      ${item.tags.length > 3 ? `+${item.tags.length - 3}` : ""}
                    </span>
                  `
                      : ""
                  }
                </div>
              </div>
            </div>
          </a>
        `;
      })
      .join("");

    updateFocusedResult();
  }

  function getIconSvg(type: string): string {
    if (type === "code") {
      return `<svg class="w-4 h-4 text-muted-foreground" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
      </svg>`;
    }
    return `<svg class="w-4 h-4 text-muted-foreground" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
    </svg>`;
  }

  function updateFocusedResult() {
    const resultItems = resultsContainer?.querySelectorAll("[data-index]");
    resultItems?.forEach((item, idx) => {
      item.setAttribute("data-focused", idx === focusedIndex ? "true" : "false");
    });
  }

  function openModal() {
    if (!modal || isOpen) return;

    isOpen = true;
    modal.classList.remove("hidden");
    modal.setAttribute("data-state", "open");
    modal.setAttribute("aria-hidden", "false");
    document.body.classList.add("search-modal-open");

    if (!indexInitialized) {
      initSearchIndex().then(() => {
        indexInitialized = true;
        renderResults();
      });
    }

    setTimeout(() => {
      searchInput?.focus();
    }, 100);
  }

  function closeModal() {
    if (!modal || !isOpen) return;

    isOpen = false;
    modal.setAttribute("data-state", "closed");
    modal.setAttribute("aria-hidden", "true");
    document.body.classList.remove("search-modal-open");

    focusedIndex = -1;
    if (searchInput) searchInput.value = "";

    setTimeout(() => {
      modal?.classList.add("hidden");
    }, 150);
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (!isOpen) {
      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault();
        openModal();
      }
      return;
    }

    if (e.key === "Escape") {
      e.preventDefault();
      closeModal();
      return;
    }

    const resultItems = resultsContainer?.querySelectorAll("[data-index]");
    if (!resultItems || resultItems.length === 0) return;

    if (e.key === "ArrowDown") {
      e.preventDefault();
      focusedIndex = Math.min(focusedIndex + 1, resultItems.length - 1);
      updateFocusedResult();
      resultItems[focusedIndex]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      focusedIndex = Math.max(focusedIndex - 1, -1);
      updateFocusedResult();
      if (focusedIndex === -1) {
        searchInput?.focus();
      } else {
        resultItems[focusedIndex]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
      }
    } else if (e.key === "Enter" && focusedIndex >= 0) {
      e.preventDefault();
      const focused = resultItems[focusedIndex] as HTMLElement;
      const href = focused?.getAttribute("href");
      if (href) {
        window.location.href = href;
        closeModal();
      }
    }
  }

  function handleSearchInput(e: Event) {
    const query = (e.target as HTMLInputElement).value;
    search(query);
  }

  function handleLoadMore() {
    displayedCount += 10;
    renderResults();
  }

  function handleRetry() {
    initSearchIndex().then(() => {
      indexInitialized = true;
      renderResults();
    });
  }

  function init() {
    // Re-query all DOM elements (fresh references after view transition swap)
    modal = document.getElementById("search-modal");
    searchInput = document.getElementById("search-input") as HTMLInputElement;
    skeleton = document.getElementById("search-skeleton");
    emptyState = document.getElementById("search-empty");
    errorState = document.getElementById("search-error");
    resultsList = document.getElementById("search-results-list");
    resultsContainer = document.getElementById("results-container");
    footer = document.getElementById("search-footer");
    loadMoreBtn = document.getElementById("load-more-btn");
    loadMoreContainer = document.getElementById("load-more-container");

    // Reset state
    isOpen = false;
    results = [];
    displayedCount = 10;
    focusedIndex = -1;

    // Set up callbacks
    setCallbacks(
      (searchResults) => {
        results = searchResults;
        displayedCount = 10;
        renderResults();
      },
      (loading) => {
        if (loading && !indexInitialized) {
          showSkeleton();
        }
      },
      (error) => {
        if (error) {
          showError(error);
        }
      }
    );

    // Bind event listeners to fresh DOM elements
    document.getElementById("close-search-modal")?.addEventListener("click", closeModal);
    searchInput?.addEventListener("input", handleSearchInput);
    document.getElementById("retry-search")?.addEventListener("click", handleRetry);
    loadMoreBtn?.addEventListener("click", handleLoadMore);

    modal?.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });

    // Expose open function globally for the header button
    (window as Window & { openSearchModal?: () => void }).openSearchModal = openModal;
  }

  // Keyboard listener only needs to be bound once (uses document, not swapped elements)
  document.addEventListener("keydown", handleKeyDown);

  // Initialize on first load and after each view transition swap
  init();

  document.addEventListener("astro:after-swap", () => {
    clearSearchIndex();
    indexInitialized = false;
    init();
  });

  window.addEventListener("beforeunload", () => {
    clearCallbacks();
    clearSearchIndex();
  });
</script>
