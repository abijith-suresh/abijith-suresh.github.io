---
import { cn } from "@/lib/utils";
import type { MarkdownHeading } from "astro";
import { List } from "lucide-astro";

interface Props {
  headings: MarkdownHeading[];
  class?: string;
}

const { headings, class: className } = Astro.props;

// Filter to only h2 and h3 headings for cleaner TOC
const filteredHeadings = headings.filter((h) => h.depth >= 2 && h.depth <= 3);

// Helper to get indentation based on heading depth
function getIndent(depth: number): string {
  return depth === 3 ? "ml-4" : "";
}
---

{
  filteredHeadings.length > 0 && (
    <nav
      id="table-of-contents"
      class:list={cn("not-prose", className)}
      aria-label="Table of Contents"
    >
      {/* Mobile: Collapsible */}
      <details class="group rounded-lg border border-border bg-muted/30 md:hidden">
        <summary class="flex cursor-pointer items-center gap-2 px-4 py-3 text-sm font-medium text-foreground">
          <List size={16} class="text-muted-foreground" />
          <span>Table of Contents</span>
          <svg
            class="ml-auto h-4 w-4 text-muted-foreground transition-transform group-open:rotate-180"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M6 9l6 6 6-6" />
          </svg>
        </summary>
        <ul class="flex flex-col gap-1 px-4 pb-4" id="toc-list-mobile">
          {filteredHeadings.map((heading) => (
            <li class:list={["text-sm", getIndent(heading.depth)]}>
              <a
                href={`#${heading.slug}`}
                class="toc-link block py-1 text-muted-foreground transition-colors hover:text-foreground"
                data-heading-slug={heading.slug}
              >
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </details>

      {/* Desktop: Always visible */}
      <div class="hidden md:block rounded-lg border border-border bg-muted/30 p-4">
        <div class="mb-3 flex items-center gap-2 text-sm font-medium text-foreground">
          <List size={16} class="text-muted-foreground" />
          <span>Table of Contents</span>
        </div>
        <ul class="flex flex-col gap-1" id="toc-list-desktop">
          {filteredHeadings.map((heading) => (
            <li class:list={["text-sm", getIndent(heading.depth)]}>
              <a
                href={`#${heading.slug}`}
                class="toc-link block py-1 text-muted-foreground transition-colors hover:text-foreground"
                data-heading-slug={heading.slug}
              >
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </div>
    </nav>
  )
}

<script>
  const HEADER_OFFSET = 100;

  class TOCController {
    private headings: HTMLElement[] = [];
    private links: NodeListOf<HTMLAnchorElement> = document.querySelectorAll(".toc-link");
    private activeSlug: string | null = null;

    init() {
      // Get all headings from the prose content
      this.headings = Array.from(
        document.querySelectorAll<HTMLElement>(".prose h2[id], .prose h3[id]")
      );

      this.links = document.querySelectorAll(".toc-link");

      if (this.headings.length === 0) return;

      // Set up scroll listener
      window.addEventListener("scroll", this.handleScroll.bind(this), {
        passive: true,
      });

      // Initial highlight
      this.handleScroll();

      // Close mobile TOC when clicking a link
      this.links.forEach((link) => {
        link.addEventListener("click", () => {
          const details = document.querySelector(
            "#table-of-contents details"
          ) as HTMLDetailsElement | null;
          if (details) {
            details.open = false;
          }
        });
      });
    }

    handleScroll() {
      const scrollY = window.scrollY + HEADER_OFFSET;

      // Find the current active heading
      let currentSlug: string | null = null;

      for (let i = this.headings.length - 1; i >= 0; i--) {
        const heading = this.headings[i];
        if (heading.offsetTop <= scrollY) {
          currentSlug = heading.id;
          break;
        }
      }

      // If we haven't scrolled past any heading, highlight the first one
      if (!currentSlug && this.headings.length > 0) {
        currentSlug = this.headings[0].id;
      }

      // Update active state if changed
      if (currentSlug !== this.activeSlug) {
        this.activeSlug = currentSlug;
        this.updateActiveLink();
      }
    }

    updateActiveLink() {
      this.links.forEach((link) => {
        const slug = link.dataset.headingSlug;
        if (slug === this.activeSlug) {
          link.classList.add("text-foreground", "font-medium");
          link.classList.remove("text-muted-foreground");
        } else {
          link.classList.remove("text-foreground", "font-medium");
          link.classList.add("text-muted-foreground");
        }
      });
    }

    cleanup() {
      window.removeEventListener("scroll", this.handleScroll.bind(this));
      this.headings = [];
      this.activeSlug = null;
    }
  }

  let controller: TOCController | null = null;

  function initTOC() {
    controller?.cleanup();
    controller = new TOCController();
    controller.init();
  }

  // Handle View Transitions
  document.addEventListener("astro:page-load", initTOC);
  document.addEventListener("astro:before-swap", () => controller?.cleanup());
</script>
